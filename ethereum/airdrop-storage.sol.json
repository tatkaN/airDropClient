"pragma solidity ^0.4.18;\n\ncontract airdrop{\n    struct airdrop_address{\n        string  typenet; \n        address wayaddress ;\n        address newnetaddress;\n        uint    balance; \n        uint    way_balance;\n        }\n    \n    uint public countAddr;\n    mapping(uint => airdrop_address) public airdrop_adrs;\n    event NewAddr(address taddress,string typenet,address nwaddr,uint balance);\n\n    function airdrop() public {}\n    function setDrop( string nNet,address wayaddr, address newaddr,uint way_bal) public {\n        if(chkAddr(newaddr) == false) return;\n        airdrop_adrs[countAddr] = airdrop_address(nNet,wayaddr,newaddr,0,way_bal);\n        airdrop_adrs[countAddr].balance = newaddr.balance;\n        NewAddr(wayaddr,nNet,newaddr,airdrop_adrs[countAddr].balance);\n        countAddr++;\n    }\n    \n    function getDrop(uint ii) public constant returns (string nnet,address adr_w,address adr_n,uint ball,uint w_ball) {\n        nnet = airdrop_adrs[ii].typenet;\n        adr_w = airdrop_adrs[ii].wayaddress;\n        adr_n  = airdrop_adrs[ii].newnetaddress;\n        ball   = airdrop_adrs[ii].balance;\n        w_ball = airdrop_adrs[ii].way_balance;\n    }\n    function chkAddr(address adr) public returns(bool aa) {\n       uint ii;\n       for (ii = 0; ii < countAddr; ii++)\n         {\n            if(airdrop_adrs[ii].newnetaddress == adr)return false;\n         }\n         return true;\n    } \n}\n"